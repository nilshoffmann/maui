/*
 * Maui, Maltcms User Interface.
 * Copyright (C) 2008-2014, The authors of Maui. All rights reserved.
 *
 * Project website: http://maltcms.sf.net
 *
 * Maui may be used under the terms of either the
 *
 * GNU Lesser General Public License (LGPL)
 * http://www.gnu.org/licenses/lgpl.html
 *
 * or the
 *
 * Eclipse Public License (EPL)
 * http://www.eclipse.org/org/documents/epl-v10.php
 *
 * As a user/recipient of Maui, you may choose which license to receive the code
 * under. Certain files or entire directories may not be covered by this
 * dual license, but are subject to licenses compatible to both LGPL and EPL.
 * License exceptions are explicitly declared in all relevant files or in a
 * LICENSE file in the relevant directories.
 *
 * Maui is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Please consult the relevant license documentation
 * for details.
 */
package net.sf.maltcms.maui.heatmapViewer;

import java.awt.BorderLayout;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.SwingUtilities;
import maltcms.datastructures.ms.IChromatogram2D;
import net.sf.maltcms.chromaui.project.api.container.Peak1DContainer;
import net.sf.maltcms.chromaui.project.api.descriptors.IChromatogramDescriptor;
import net.sf.maltcms.chromaui.project.api.descriptors.IPeak2DAnnotationDescriptor;
import net.sf.maltcms.chromaui.project.api.descriptors.IPeakAnnotationDescriptor;
import net.sf.maltcms.chromaui.ui.support.api.AProgressAwareRunnable;
import net.sf.maltcms.maui.heatmapViewer.plot3d.builder.concrete.SurfaceFactory;
import net.sf.maltcms.maui.heatmapViewer.plot3d.builder.concrete.ViewportMapper;
import org.jzy3d.chart.Chart;
import org.jzy3d.chart.controllers.mouse.camera.NewtCameraMouseController;
import org.jzy3d.chart.factories.AWTChartComponentFactory;
import org.jzy3d.chart.factories.IChartComponentFactory;
import org.jzy3d.colors.Color;
import org.jzy3d.maths.Coord3d;
import org.jzy3d.maths.Rectangle;
import org.jzy3d.plot3d.primitives.AbstractDrawable;
import org.jzy3d.plot3d.primitives.Tube;
import org.jzy3d.plot3d.rendering.canvas.CanvasNewtAwt;
import org.jzy3d.plot3d.rendering.canvas.Quality;
import org.jzy3d.plot3d.rendering.scene.Graph;
import org.netbeans.api.settings.ConvertAsProperties;
import org.openide.awt.ActionID;
import org.openide.awt.ActionReference;
import org.openide.util.Exceptions;
import org.openide.util.NbBundle;
import org.openide.windows.TopComponent;

/**
 * Top component which displays something.
 */
@ConvertAsProperties(dtd = "-//net.sf.maltcms.maui.heatmapViewer//HeatmapViewer//EN",
        autostore = false)
@TopComponent.Description(preferredID = "HeatmapViewerTopComponent",
        //iconBase="SET/PATH/TO/ICON/HERE",
        persistenceType = TopComponent.PERSISTENCE_NEVER)
@TopComponent.Registration(mode = "editor", openAtStartup = false)
@ActionID(category = "Window", id = "net.sf.maltcms.maui.heatmapViewer.HeatmapViewerTopComponent")
@ActionReference(path = "Menu/Window" /*, position = 333 */)
@TopComponent.OpenActionRegistration(displayName = "#CTL_HeatmapViewerAction",
        preferredID = "HeatmapViewerTopComponent")
public final class HeatmapViewerTopComponent extends TopComponent {

    private Chart chart = null;
    private CanvasNewtAwt canvas = null;
    private AbstractDrawable cc;
    private ViewportMapper mapper = null;
    private Rectangle roi = null;
    private AtomicBoolean updatingScene = new AtomicBoolean(false);
    private AtomicBoolean chartCreated = new AtomicBoolean(false);
    private ExecutorService es = Executors.newSingleThreadExecutor();

    public HeatmapViewerTopComponent() {
        initComponents();
        setName(NbBundle.getMessage(HeatmapViewerTopComponent.class, "CTL_HeatmapViewerTopComponent"));
        setToolTipText(NbBundle.getMessage(HeatmapViewerTopComponent.class, "HINT_HeatmapViewerTopComponent"));
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setLayout(new java.awt.BorderLayout());
    }// </editor-fold>//GEN-END:initComponents

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    @Override
    protected void componentOpened() {
        super.componentOpened();
        System.out.println("Opened");
//        createChart();
    }

    @Override
    protected void componentClosed() {
        super.componentClosed();
        System.out.println("Closed");
        if (chartCreated.get() && chart != null) {
            try {
                //dispose chart resources
                chart.dispose();
            } catch (Exception e) {
                Exceptions.printStackTrace(e);
            } finally {
                //cleanup
                chart = null;
//                ctc = null;
                remove(canvas);
                //dispose of canvas and native resources
                canvas.dispose();
                chartCreated.set(false);
            }
        }
    }

    @Override
    protected void componentShowing() {
        super.componentShowing();
        System.out.println("Showing");
        if (chartCreated.get()) {
//            if (ctc != null) {
//                if (toggleAnimation.isSelected()) {
//                    //reenable animation if animation is toggled and component is set to visible
//                    ctc.start();
//                }
//            }
        }
    }

    @Override
    protected void componentHidden() {
        super.componentHidden();
        System.out.println("Hidden");
        if (chartCreated.get()) {
//            if (ctc != null) {
//                //stop animation if top component is not visible
//                ctc.stop();
//            }
        }
    }

    @Override
    protected void componentActivated() {
        super.componentActivated();
        System.out.println("Activated");
        if (chartCreated.get()) {
            if (chart != null) {
                CanvasNewtAwt cna = (CanvasNewtAwt) chart.getCanvas();
                cna.setSize(getSize());
                //need to update complete component tree
                invalidate();
                getTopLevelAncestor().invalidate();
                getTopLevelAncestor().revalidate();
            }
        }
    }

    public void setMapper(ViewportMapper mapper, IChromatogramDescriptor chromatogram) {
        this.mapper = mapper;
        this.roi = mapper.getViewport();
        if (chromatogram.getSeparationType().getFeatureDimensions() == 2) {
            buildScene(chromatogram);
        } else {
            throw new IllegalArgumentException("Can only handle 2D chromatograms!");
        }
    }

    private class SceneUpdater extends AProgressAwareRunnable {

        private final Graph graph;

        public SceneUpdater(Graph graph) {
            this.graph = graph;
        }

        @Override
        public void run() {
            try {
                setEnabled(false);
                progressHandle.start();
                progressHandle.progress("Removing old scene elements");
//                synchronized (graph) {
                if (cc != null) {
                    graph.remove(cc, false);
                }
//                for (BarChartBar<String> bcb : barChartBars) {
//                    graph.remove(bcb, false);
//                }
                SurfaceFactory sf = new SurfaceFactory();

                progressHandle.progress("Building surface");
                boolean fastTesselation = true;
                cc = sf.createSurface(mapper.getClippedViewport(roi), mapper,
                        fastTesselation, (int) (roi.width), (int) (roi.height));
                progressHandle.progress("Adding to scene");
                Logger.getLogger(getClass().getName()).info("Adding surface to scene graph");
                graph.add(cc);
                SwingUtilities.invokeLater(new Runnable() {
                    @Override
                    public void run() {
                        setEnabled(true);
                        chart.getCanvas().forceRepaint();
                        progressHandle.progress("Done!");
                        invalidate();
                        getTopLevelAncestor().invalidate();
                        getTopLevelAncestor().revalidate();
                    }
                });

            } finally {
                progressHandle.finish();
            }
        }
    }

//    private void addComposite(Graph graph) {
//        SceneUpdater su = new SceneUpdater(graph);
//        SceneUpdater.createAndRun("Scene Updater", su);
//    }
    private Chart getChart() {
        if (chart == null) {
            AWTChartComponentFactory accf = new AWTChartComponentFactory();
            chart = accf.newChart(Quality.Intermediate, IChartComponentFactory.Toolkit.newt.name());
            chart.getView().setMaximized(true);
            if(canvas!=null) {
                remove(canvas);
                canvas.dispose();
            }
            canvas = (CanvasNewtAwt) chart.getCanvas();
            chart.getAxeLayout().setXAxeLabel("Retention Time 1");
            chart.getAxeLayout().setYAxeLabel("Retention Time 2");
            chart.getAxeLayout().setZAxeLabel("Total Intensity");
            chart.getView().setMaximized(true);
            chart.getView().getCamera().setScreenGridDisplayed(false);
            NewtCameraMouseController mouse = new NewtCameraMouseController(chart);
            chart.addController(mouse);
//            mouse.addControllerEventListener(new ControllerEventListener() {
//                @Override
//                public void controllerEventFired(ControllerEvent e) {
//                    if (e.getType() == ControllerType.PAN) {
//                        Logger.getLogger(getClass().getName()).log(Level.FINE, "Mouse[PAN]: {0}", e.getValue());
//                    } else if (e.getType() == ControllerType.SHIFT) {
//                        Logger.getLogger(getClass().getName()).log(Level.FINE, "Mouse[SHIFT]: {0}", e.getValue());
//                    } else if (e.getType() == ControllerType.ZOOM) {
//                        Logger.getLogger(getClass().getName()).log(Level.FINE, "Mouse[ZOOM]: {0}", e.getValue());
//                    } else if (e.getType() == ControllerType.ROTATE) {
//                        Logger.getLogger(getClass().getName()).log(Level.FINE, "Mouse[ROTATE]:{0}", e.getValue());
//                    }
//                }
//            });
            SwingUtilities.invokeLater(new Runnable() {

                @Override
                public void run() {
                    canvas.setMinimumSize(getMinimumSize());
                    canvas.setMaximumSize(getMaximumSize());
                    canvas.setPreferredSize(getPreferredSize());
                    add(canvas, BorderLayout.CENTER);
//                    setCameraThreadController(ctc);
//                    if (toggleAnimation.isSelected()) {
//                        ctc.start();
//                    }
                    //need to update complete component tree
                    invalidate();
                    getTopLevelAncestor().invalidate();
                    getTopLevelAncestor().revalidate();
                }
            });
        }
        return chart;
    }

    private void buildScene(final IChromatogramDescriptor chromatogram) {
        if (cc == null) {
//            Runnable runnable = new Runnable() {
////
//                @Override
//                public void run() {
                    SurfaceFactory sf = new SurfaceFactory();
                    IChromatogram2D chrom = (IChromatogram2D) chromatogram.getChromatogram();
                    cc = sf.createSurfaceChrom(mapper.getViewport(), mapper, true, chrom.getNumberOfModulations() / 3, chrom.getNumberOfScansPerModulation() / 3);
                    cc.setLegend(new org.jzy3d.plot3d.rendering.legends.colorbars.AWTColorbarLegend(cc, getChart().getView().getAxe().getLayout()));
                    cc.setLegendDisplayed(true);
                    final List<AbstractDrawable> drawables = new ArrayList<>();
//            drawables.add(cc);
                    int peakPickingId = 0;
                    for (Peak1DContainer peaks : chromatogram.getProject().getPeaks(chromatogram)) {
                        java.awt.Color fillColor = peaks.getColor();
                        if (fillColor == null || fillColor.equals(java.awt.Color.WHITE) || fillColor.equals(new java.awt.Color(255, 255, 255, 0))) {
//				System.out.println("Peak annotation color was null or white, using color from treatment group!");
                            fillColor = peaks.getChromatogram().getTreatmentGroup().getColor();
                        }
                        float[] colors = fillColor.getColorComponents(null);
                        for (IPeakAnnotationDescriptor descr : peaks.getMembers()) {
                            if (descr instanceof IPeak2DAnnotationDescriptor) {
                                IPeak2DAnnotationDescriptor peak2d = (IPeak2DAnnotationDescriptor) descr;
                                Tube tube = new Tube();
                                tube.setData(new Coord3d(
                                        peak2d.getFirstColumnRt(),
                                        peak2d.getSecondColumnRt(),
                                        0.0d),
                                        (float) (chrom.getModulationDuration() / (float) chrom.getNumberOfScansPerModulation()) * 5,
                                        (float) (chrom.getModulationDuration() / (float) chrom.getNumberOfScansPerModulation()),
                                        (float) Math.min(
                                                mapper.f(peak2d.getFirstColumnRt(), peak2d.getSecondColumnRt())
                                                + ((cc.getBounds().getZmax() - cc.getBounds().getZmin()) / 100.0f * 5.0f),
                                                cc.getBounds().getZmax()),
                                        5, 5);
//                        tube.setColor(new Color(colors[0], colors[1], colors[2], 1.0f));
                                tube.setWireframeDisplayed(true);
                                tube.setWireframeColor(new Color(colors[0], colors[1], colors[2], 0.7f));
                                tube.setFaceDisplayed(false);
                                drawables.add(tube);
                            } else {
                                Logger.getLogger(HeatmapViewerTopComponent.class.getName()).log(Level.WARNING, "Ignoring 1D Peak {}", descr.getDisplayName());
                            }
                        }
                    }
//                    BarChartBar<String> bcb = new BarChartBar<String>(chart, item,
//                            item);
//                    bcb.setData(new Coord3d(xpos, ypos,
//                            cc.getBounds().getZmin()), 10.0f, 10.0f, (float) mapper.f(xpos,
//                                    ypos) - cc.getBounds().getZmin(),
//                            new Color((float) Math.random(), (float) Math.random(),
//                                    (float) Math.random(), 0.3f));
//                    chart.getScene().getGraph().add(bcb);
//                    barChartBars.add(bcb);
//                    SwingUtilities.invokeLater(new Runnable() {
//
//                        @Override
//                        public void run() {
//                            canvas.setMinimumSize(getMinimumSize());
//                            canvas.setMaximumSize(getMaximumSize());
//                            canvas.setPreferredSize(getPreferredSize());
                            getChart().getScene().getGraph().add(cc, false);
                            getChart().getScene().getGraph().add(drawables, true);
//                    setCameraThreadController(ctc);
//                    if (toggleAnimation.isSelected()) {
//                        ctc.start();
//                    }
                            //need to update complete component tree
                            invalidate();
                            getTopLevelAncestor().invalidate();
                            getTopLevelAncestor().revalidate();
//                            getTopLevelAncestor().invalidate();
//                            getTopLevelAncestor().revalidate();public void run() {
//                            invalidate();
//                            getTopLevelAncestor().invalidate();
//                            getTopLevelAncestor().revalidate();

//                        }
//                    });

//                }
//
//
//                }

//            };
//            es.submit(runnable);
        }
    }

    void writeProperties(java.util.Properties p) {
        // better to version settings since initial version as advocated at
        // http://wiki.apidesign.org/wiki/PropertyFiles
        p.setProperty("version", "1.0");
        // TODO store your settings
    }

    void readProperties(java.util.Properties p) {
        String version = p.getProperty("version");
        // TODO read your settings according to their version
    }
}
